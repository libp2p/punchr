syntax = "proto2";

option go_package = "github.com/dennis-tra/punchr/pkg/pb";

service PunchrService {
  // Register takes punchr client information and saves them to the database.
  // This should be called upon start of a client.
  rpc Register(RegisterRequest) returns (RegisterResponse);

  // GetAddrInfo returns peer address information that should be used to attempt
  // a hole punch. Clients should call this endpoint periodically.
  rpc GetAddrInfo(GetAddrInfoRequest) returns (GetAddrInfoResponse);

  // TrackHolePunch takes measurement data from the client and persists them in the database
  rpc TrackHolePunch(TrackHolePunchRequest) returns (TrackHolePunchResponse);
}

message RegisterRequest {
  required bytes client_id = 1;
  required string agent_version = 2;
  repeated string protocols = 3;
}

message RegisterResponse {
  required int64 db_peer_id = 1;
}

message GetAddrInfoRequest {
  // Host ID for that the client is requesting a peer to hole punch
  required bytes host_id = 1;

  // All host IDs that the client is managing
  repeated bytes all_host_ids = 2;
}

message GetAddrInfoResponse {
  required bytes remote_id = 1;
  repeated bytes multi_addresses = 2;
}

enum HolePunchOutcome {
  HOLE_PUNCH_OUTCOME_UNKNOWN = 0;

  // Could not connect to remote peer via relay
  HOLE_PUNCH_OUTCOME_NO_CONNECTION = 1;

  // Hole punch was not initiated from the remote peer
  // because the /libp2p/dcutr stream was not opened.
  HOLE_PUNCH_OUTCOME_NO_STREAM = 2;

  // Hole punch was cancelled by the user
  HOLE_PUNCH_OUTCOME_CANCELLED = 3;

  // The hole punch was attempted several times but failed
  HOLE_PUNCH_OUTCOME_FAILED = 4;

  // The hole punch was performed and successful
  HOLE_PUNCH_OUTCOME_SUCCESS = 5;
}

message TrackHolePunchRequest {
  // Peer ID of the requesting punchr client
  required bytes client_id = 1;

  // Peer ID of the remote peer that was hole punched
  required bytes remote_id = 2;

  // The multi addresses that were used to attempt a hole punch
  // (the same that got served in the first place via GetAddrInfo)
  repeated bytes remote_multi_addresses = 3;

  // Unix timestamp in milliseconds of when the connection to the remote peer was initiated
  required uint64 connect_started_at = 4;

  // Unix timestamp in milliseconds of when the connection to the remote peer via the relay was established (or has failed)
  required uint64 connect_ended_at = 5;

  // Information about each hole punch attempt
  repeated HolePunchAttempt hole_punch_attempts = 6;

  // The multi addresses of the open connections AFTER the hole punch process.
  // This field can be used to track which transport protocols were more successful for hole punching.
  repeated bytes open_multi_addresses = 7;

  // Whether the open_multi_addresses contains at least one direct connection
  // to the remote peer.
  required bool has_direct_conns = 8;

  // The reason why the hole punch ended (direct dial succeeded, protocol error occurred, hole punch procedure finished)
  required HolePunchOutcome outcome = 9;

  // Unix timestamp in milliseconds of when the overall hole punch process ended
  required uint64 ended_at = 10;
}

message TrackHolePunchResponse {}

message HolePunchAttempt {
  // Unix timestamp in milliseconds of when the /libp2p/dcutr stream was opened
  required uint64 opened_at = 1;

  // Unix timestamp in milliseconds of when this hole punching attempt was started
  required uint64 started_at = 2;

  // Unix timestamp in milliseconds of when this hole punching attempt terminated
  required uint64 ended_at = 3;

  // Start round trip time in seconds that falls out of the `holepunch.StartHolePunchEvt`
  optional float start_rtt = 4;

  // The elapsed time in seconds from start to finish of the hole punch
  required float elapsed_time = 5;

  // The outcome of the hole punch
  required HolePunchAttemptOutcome outcome = 6;

  // The error that occurred if the hole punch failed
  optional string error = 7;

  // The error that occurred if the connection reversal failed. This is only set of
  // the multi addresses for the remote peer contained a publicly reachable non-relay multi address
  optional string direct_dial_error = 8;
}

enum HolePunchAttemptOutcome {
  HOLE_PUNCH_ATTEMPT_OUTCOME_UNKNOWN = 0;

  // Should never happen on our side. This happens if
  // the connection reversal from our side succeeded.
  HOLE_PUNCH_ATTEMPT_DIRECT_DIAL = 1;

  // Can happen if, e.g., the stream was reset mid-flight
  HOLE_PUNCH_ATTEMPT_PROTOCOL_ERROR = 2;

  // The overall hole punch was cancelled by the user
  HOLE_PUNCH_ATTEMPT_CANCELLED = 3;

  // The /libp2p/dcutr stream was opened but the hole punch was not initiated in time
  HOLE_PUNCH_ATTEMPT_TIMEOUT = 4;

  // The hole punch was performed but has failed
  HOLE_PUNCH_ATTEMPT_FAILED = 5;

  // The hole punch was performed and was successful
  HOLE_PUNCH_ATTEMPT_SUCCESS = 6;
}
